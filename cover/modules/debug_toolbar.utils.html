<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
    <title>Test coverage report: debug_toolbar.utils</title>
    <style type="text/css" media="screen">
      a
      {
        color: #3d707a;
      }
      
      a:hover, a:active
      {
        color: #bf7d18;
      }
    
      body 
      {
        font-family: "Lucida Sans Unicode", "Lucida Grande", sans-serif;
        font-size: 13px;
      }
      
      .nav 
      {
        font-size: 12px;
        margin-left: 50px;
      }

      .ignored
      {
        color: #707070;
      }

      .executed 
      {
        color: #3d9900;
      }

      .missed 
      {
        color: red;
        font-weight: bold;
      }

      .excluded 
      {
        color: #6090f0;
        font-weight: lighter;
      }
    
      #content-header 
      {
        font-size: 12px;
        padding: 18px 0 18px 50px;
      }

      #content-header h1 
      {
        font-size: 16px;
        margin: 10px 0 0 0;
        color: #909090;
      }
      
      #module-name
      {
        color: #583707;
      }
    
      #content-header p
      {
        font-size: 13px;
        margin: 0;
        color: #909090;
      }

      #content-header .normal 
      {
        color: #609030;
      }

      #content-header .warning 
      {
        color: #d0a000;
      }

      #content-header .critical 
      {
        color: red;
      }
      
      #source-listing 
      {
        margin-bottom: 24px;
      }

      #source-listing ol 
      {
        padding: 0 0 0 50px;
        width: 90%;
        font-family: monospace;
        list-style-position: outside;
      }

      #source-listing ol li 
      {
        line-height: 18px;
        font-size: small;
      }
        
      #source-listing ol code 
      {
        padding:  0 .001em 0 0; /* Firefox doesn't render empty li's properly */
        font-size: medium;
        white-space: pre;
      }
   </style>
  </head>

  <body>

<div class="nav">
  <a href="debug_toolbar.panels.versions.html">debug_toolbar.panels.versions</a> &lt;&lt;
  <a href="../index.html">index</a>
  &gt;&gt; <a href="debug_toolbar.views.html">debug_toolbar.views</a>
</div>

<div id="content-header">
  <h1>
    <span id="module-name">debug_toolbar.utils</span>:
    155 total statements,
    <span class="critical">0.0% covered</span>
  </h1>
  <p>Generated: Thu 2015-05-07 01:13 UTC</p>
  <p>Source file: /usr/local/lib/python2.7/dist-packages/debug_toolbar/utils.py</p>
  <p>
    Stats:
    <span class="executed">0 executed</span>,
    <span class="missed">138 missed</span>,
    <span class="excluded">17 excluded</span>,
    <span class="ignored">110 ignored</span> 
  </p> 
</div>

<div id="source-listing">
  <ol>
    <li class="excluded"><code>from __future__ import absolute_import, unicode_literals</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>try:</code></li>
<li class="excluded"><code>    from importlib import import_module</code></li>
<li class="missed"><code>except ImportError:  # python 2.6</code></li>
<li class="excluded"><code>    from django.utils.importlib import import_module</code></li>
<li class="excluded"><code>import inspect</code></li>
<li class="excluded"><code>import os.path</code></li>
<li class="excluded"><code>import re</code></li>
<li class="excluded"><code>import sys</code></li>
<li class="missed"><code>try:</code></li>
<li class="excluded"><code>    import threading</code></li>
<li class="missed"><code>except ImportError:</code></li>
<li class="missed"><code>    threading = None</code></li>
<li class="ignored"><code></code></li>
<li class="excluded"><code>import django</code></li>
<li class="excluded"><code>from django.core.exceptions import ImproperlyConfigured</code></li>
<li class="excluded"><code>from django.template import Node</code></li>
<li class="excluded"><code>from django.utils.encoding import force_text</code></li>
<li class="excluded"><code>from django.utils.html import escape</code></li>
<li class="excluded"><code>from django.utils.safestring import mark_safe</code></li>
<li class="excluded"><code>from django.utils import six</code></li>
<li class="excluded"><code>from django.views.debug import linebreak_iter</code></li>
<li class="ignored"><code></code></li>
<li class="excluded"><code>from .settings import CONFIG</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code># Figure out some paths</code></li>
<li class="missed"><code>django_path = os.path.realpath(os.path.dirname(django.__file__))</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>def get_module_path(module_name):</code></li>
<li class="missed"><code>    try:</code></li>
<li class="missed"><code>        module = import_module(module_name)</code></li>
<li class="missed"><code>    except ImportError as e:</code></li>
<li class="missed"><code>        raise ImproperlyConfigured(</code></li>
<li class="ignored"><code>            'Error importing HIDE_IN_STACKTRACES: %s' % (e,))</code></li>
<li class="ignored"><code>    else:</code></li>
<li class="missed"><code>        source_path = inspect.getsourcefile(module)</code></li>
<li class="missed"><code>        if source_path.endswith('__init__.py'):</code></li>
<li class="missed"><code>            source_path = os.path.dirname(source_path)</code></li>
<li class="missed"><code>        return os.path.realpath(source_path)</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>hidden_paths = [</code></li>
<li class="ignored"><code>    get_module_path(module_name)</code></li>
<li class="ignored"><code>    for module_name in CONFIG['HIDE_IN_STACKTRACES']</code></li>
<li class="ignored"><code>]</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>def omit_path(path):</code></li>
<li class="missed"><code>    return any(path.startswith(hidden_path) for hidden_path in hidden_paths)</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>def tidy_stacktrace(stack):</code></li>
<li class="ignored"><code>    """</code></li>
<li class="ignored"><code>    Clean up stacktrace and remove all entries that:</code></li>
<li class="ignored"><code>    1. Are part of Django (except contrib apps)</code></li>
<li class="ignored"><code>    2. Are part of socketserver (used by Django's dev server)</code></li>
<li class="ignored"><code>    3. Are the last entry (which is part of our stacktracing code)</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>    ``stack`` should be a list of frame tuples from ``inspect.stack()``</code></li>
<li class="ignored"><code>    """</code></li>
<li class="missed"><code>    trace = []</code></li>
<li class="missed"><code>    for frame, path, line_no, func_name, text in (f[:5] for f in stack):</code></li>
<li class="missed"><code>        if omit_path(os.path.realpath(path)):</code></li>
<li class="missed"><code>            continue</code></li>
<li class="missed"><code>        text = (''.join(force_text(t) for t in text)).strip() if text else ''</code></li>
<li class="missed"><code>        trace.append((path, line_no, func_name, text))</code></li>
<li class="missed"><code>    return trace</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>def render_stacktrace(trace):</code></li>
<li class="missed"><code>    stacktrace = []</code></li>
<li class="missed"><code>    for frame in trace:</code></li>
<li class="missed"><code>        params = map(escape, frame[0].rsplit(os.path.sep, 1) + list(frame[1:]))</code></li>
<li class="missed"><code>        params_dict = dict((six.text_type(idx), v) for idx, v in enumerate(params))</code></li>
<li class="missed"><code>        try:</code></li>
<li class="missed"><code>            stacktrace.append('&lt;span class="djdt-path"&gt;%(0)s/&lt;/span&gt;'</code></li>
<li class="ignored"><code>                              '&lt;span class="djdt-file"&gt;%(1)s&lt;/span&gt;'</code></li>
<li class="ignored"><code>                              ' in &lt;span class="djdt-func"&gt;%(3)s&lt;/span&gt;'</code></li>
<li class="ignored"><code>                              '(&lt;span class="djdt-lineno"&gt;%(2)s&lt;/span&gt;)\n'</code></li>
<li class="ignored"><code>                              '  &lt;span class="djdt-code"&gt;%(4)s&lt;/span&gt;'</code></li>
<li class="ignored"><code>                              % params_dict)</code></li>
<li class="missed"><code>        except KeyError:</code></li>
<li class="ignored"><code>            # This frame doesn't have the expected format, so skip it and move on to the next one</code></li>
<li class="missed"><code>            continue</code></li>
<li class="missed"><code>    return mark_safe('\n'.join(stacktrace))</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>def get_template_info():</code></li>
<li class="missed"><code>    template_info = None</code></li>
<li class="missed"><code>    cur_frame = sys._getframe().f_back</code></li>
<li class="missed"><code>    try:</code></li>
<li class="missed"><code>        while cur_frame is not None:</code></li>
<li class="missed"><code>            in_utils_module = cur_frame.f_code.co_filename.endswith(</code></li>
<li class="ignored"><code>                "/debug_toolbar/utils.py"</code></li>
<li class="ignored"><code>            )</code></li>
<li class="missed"><code>            is_get_template_context = (</code></li>
<li class="ignored"><code>                cur_frame.f_code.co_name == get_template_context.__name__</code></li>
<li class="ignored"><code>            )</code></li>
<li class="missed"><code>            if in_utils_module and is_get_template_context:</code></li>
<li class="ignored"><code>                # If the method in the stack trace is this one</code></li>
<li class="ignored"><code>                # then break from the loop as it's being check recursively.</code></li>
<li class="missed"><code>                break</code></li>
<li class="missed"><code>            elif cur_frame.f_code.co_name == 'render':</code></li>
<li class="missed"><code>                node = cur_frame.f_locals['self']</code></li>
<li class="missed"><code>                if isinstance(node, Node):</code></li>
<li class="missed"><code>                    template_info = get_template_context(node.source)</code></li>
<li class="missed"><code>                    break</code></li>
<li class="missed"><code>            cur_frame = cur_frame.f_back</code></li>
<li class="missed"><code>    except Exception:</code></li>
<li class="missed"><code>        pass</code></li>
<li class="missed"><code>    del cur_frame</code></li>
<li class="missed"><code>    return template_info</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>def get_template_context(source, context_lines=3):</code></li>
<li class="missed"><code>    line = 0</code></li>
<li class="missed"><code>    upto = 0</code></li>
<li class="missed"><code>    source_lines = []</code></li>
<li class="ignored"><code>    # before = during = after = ""</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    origin, (start, end) = source</code></li>
<li class="missed"><code>    template_source = origin.reload()</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    for num, next in enumerate(linebreak_iter(template_source)):</code></li>
<li class="missed"><code>        if start &gt;= upto and end &lt;= next:</code></li>
<li class="missed"><code>            line = num</code></li>
<li class="ignored"><code>            # before = template_source[upto:start]</code></li>
<li class="ignored"><code>            # during = template_source[start:end]</code></li>
<li class="ignored"><code>            # after = template_source[end:next]</code></li>
<li class="missed"><code>        source_lines.append((num, template_source[upto:next]))</code></li>
<li class="missed"><code>        upto = next</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    top = max(1, line - context_lines)</code></li>
<li class="missed"><code>    bottom = min(len(source_lines), line + 1 + context_lines)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    context = []</code></li>
<li class="missed"><code>    for num, content in source_lines[top:bottom]:</code></li>
<li class="missed"><code>        context.append({</code></li>
<li class="ignored"><code>            'num': num,</code></li>
<li class="ignored"><code>            'content': content,</code></li>
<li class="ignored"><code>            'highlight': (num == line),</code></li>
<li class="ignored"><code>        })</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    return {</code></li>
<li class="ignored"><code>        'name': origin.name,</code></li>
<li class="ignored"><code>        'context': context,</code></li>
<li class="ignored"><code>    }</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>def get_name_from_obj(obj):</code></li>
<li class="missed"><code>    if hasattr(obj, '__name__'):</code></li>
<li class="missed"><code>        name = obj.__name__</code></li>
<li class="missed"><code>    elif hasattr(obj, '__class__') and hasattr(obj.__class__, '__name__'):</code></li>
<li class="missed"><code>        name = obj.__class__.__name__</code></li>
<li class="ignored"><code>    else:</code></li>
<li class="missed"><code>        name = '&lt;unknown&gt;'</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    if hasattr(obj, '__module__'):</code></li>
<li class="missed"><code>        module = obj.__module__</code></li>
<li class="missed"><code>        name = '%s.%s' % (module, name)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    return name</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>def getframeinfo(frame, context=1):</code></li>
<li class="ignored"><code>    """</code></li>
<li class="ignored"><code>    Get information about a frame or traceback object.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>    A tuple of five things is returned: the filename, the line number of</code></li>
<li class="ignored"><code>    the current line, the function name, a list of lines of context from</code></li>
<li class="ignored"><code>    the source code, and the index of the current line within that list.</code></li>
<li class="ignored"><code>    The optional second argument specifies the number of lines of context</code></li>
<li class="ignored"><code>    to return, which are centered around the current line.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>    This originally comes from ``inspect`` but is modified to handle issues</code></li>
<li class="ignored"><code>    with ``findsource()``.</code></li>
<li class="ignored"><code>    """</code></li>
<li class="missed"><code>    if inspect.istraceback(frame):</code></li>
<li class="missed"><code>        lineno = frame.tb_lineno</code></li>
<li class="missed"><code>        frame = frame.tb_frame</code></li>
<li class="ignored"><code>    else:</code></li>
<li class="missed"><code>        lineno = frame.f_lineno</code></li>
<li class="missed"><code>    if not inspect.isframe(frame):</code></li>
<li class="missed"><code>        raise TypeError('arg is not a frame or traceback object')</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    filename = inspect.getsourcefile(frame) or inspect.getfile(frame)</code></li>
<li class="missed"><code>    if context &gt; 0:</code></li>
<li class="missed"><code>        start = lineno - 1 - context // 2</code></li>
<li class="missed"><code>        try:</code></li>
<li class="missed"><code>            lines, lnum = inspect.findsource(frame)</code></li>
<li class="missed"><code>        except Exception:   # findsource raises platform-dependant exceptions</code></li>
<li class="missed"><code>            first_lines = lines = index = None</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="missed"><code>            start = max(start, 1)</code></li>
<li class="missed"><code>            start = max(0, min(start, len(lines) - context))</code></li>
<li class="missed"><code>            first_lines = lines[:2]</code></li>
<li class="missed"><code>            lines = lines[start:(start + context)]</code></li>
<li class="missed"><code>            index = lineno - 1 - start</code></li>
<li class="ignored"><code>    else:</code></li>
<li class="missed"><code>        first_lines = lines = index = None</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>    # Code taken from Django's ExceptionReporter._get_lines_from_file</code></li>
<li class="missed"><code>    if first_lines and isinstance(first_lines[0], bytes):</code></li>
<li class="missed"><code>        encoding = 'ascii'</code></li>
<li class="missed"><code>        for line in first_lines[:2]:</code></li>
<li class="ignored"><code>            # File coding may be specified. Match pattern from PEP-263</code></li>
<li class="ignored"><code>            # (http://www.python.org/dev/peps/pep-0263/)</code></li>
<li class="missed"><code>            match = re.search(br'coding[:=]\s*([-\w.]+)', line)</code></li>
<li class="missed"><code>            if match:</code></li>
<li class="missed"><code>                encoding = match.group(1).decode('ascii')</code></li>
<li class="missed"><code>                break</code></li>
<li class="missed"><code>        lines = [line.decode(encoding, 'replace') for line in lines]</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    if hasattr(inspect, 'Traceback'):</code></li>
<li class="missed"><code>        return inspect.Traceback(filename, lineno, frame.f_code.co_name, lines, index)</code></li>
<li class="ignored"><code>    else:</code></li>
<li class="missed"><code>        return (filename, lineno, frame.f_code.co_name, lines, index)</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>def get_stack(context=1):</code></li>
<li class="ignored"><code>    """</code></li>
<li class="ignored"><code>    Get a list of records for a frame and all higher (calling) frames.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>    Each record contains a frame object, filename, line number, function</code></li>
<li class="ignored"><code>    name, a list of lines of context, and index within the context.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>    Modified version of ``inspect.stack()`` which calls our own ``getframeinfo()``</code></li>
<li class="ignored"><code>    """</code></li>
<li class="missed"><code>    frame = sys._getframe(1)</code></li>
<li class="missed"><code>    framelist = []</code></li>
<li class="missed"><code>    while frame:</code></li>
<li class="missed"><code>        framelist.append((frame,) + getframeinfo(frame, context))</code></li>
<li class="missed"><code>        frame = frame.f_back</code></li>
<li class="missed"><code>    return framelist</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>class ThreadCollector(object):</code></li>
<li class="missed"><code>    def __init__(self):</code></li>
<li class="missed"><code>        if threading is None:</code></li>
<li class="missed"><code>            raise NotImplementedError(</code></li>
<li class="ignored"><code>                "threading module is not available, "</code></li>
<li class="ignored"><code>                "this panel cannot be used without it")</code></li>
<li class="missed"><code>        self.collections = {}  # a dictionary that maps threads to collections</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def get_collection(self, thread=None):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Returns a list of collected items for the provided thread, of if none</code></li>
<li class="ignored"><code>        is provided, returns a list for the current thread.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        if thread is None:</code></li>
<li class="missed"><code>            thread = threading.currentThread()</code></li>
<li class="missed"><code>        if thread not in self.collections:</code></li>
<li class="missed"><code>            self.collections[thread] = []</code></li>
<li class="missed"><code>        return self.collections[thread]</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def clear_collection(self, thread=None):</code></li>
<li class="missed"><code>        if thread is None:</code></li>
<li class="missed"><code>            thread = threading.currentThread()</code></li>
<li class="missed"><code>        if thread in self.collections:</code></li>
<li class="missed"><code>            del self.collections[thread]</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def collect(self, item, thread=None):</code></li>
<li class="missed"><code>        self.get_collection(thread).append(item)</code></li>
  </ol>
</div>

<div class="nav">
  <a href="debug_toolbar.panels.versions.html">debug_toolbar.panels.versions</a> &lt;&lt;
  <a href="../index.html">index</a>
  &gt;&gt; <a href="debug_toolbar.views.html">debug_toolbar.views</a>
</div>

  </body>
</html>

